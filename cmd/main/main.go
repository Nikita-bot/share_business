// Code generated by mtgroup-generator.
package main

import (
	"context"
	"crypto/tls"
	"flag"
	"fmt"
	"time"

	"wash-bonus/internal/api"
	"wash-bonus/internal/app"
	"wash-bonus/internal/authorization"
	"wash-bonus/internal/dal"
	"wash-bonus/internal/def"

	extauthapi "github.com/mtgroupit/mt-mock-extauthapi"
	"github.com/powerman/pqx"
	"github.com/powerman/structlog"
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

const (
	connectTimeout = 3 * time.Second

	ExtauthEndpointFlag = "extauth.endpoint"
)

var (
	testRepo *dal.Repo
	testAppl app.App

	log = structlog.New()
	cfg struct {
		logLevel        string
		gooseDir        string
		db              pqx.Config
		api             api.Config
		extauthEndpoint string
		resetDB         bool
	}
)

func init() {
	var dbSSLModeRequire bool

	flag.BoolVar(&dbSSLModeRequire, "db.ssl-mode-is-req", def.DBSSLModeIsReq, "PostgreSQL SSL mode")

	if dbSSLModeRequire {
		cfg.db.SSLMode = pqx.SSLRequire
	} else {
		cfg.db.SSLMode = pqx.SSLDisable
	}
	flag.StringVar(&cfg.logLevel, "log.level", "debug", "log `level` (debug|info|warn|err)")

	flag.StringVar(&cfg.gooseDir, "goose.dir", def.GooseDir, "goose migrations `dir`")
	flag.StringVar(&cfg.db.Host, "db.host", def.DBHost, "PostgreSQL `host`")
	flag.IntVar(&cfg.db.Port, "db.port", def.DBPort, "PostgreSQL `port`")
	flag.StringVar(&cfg.db.User, "db.user", def.DBUser, "PostgreSQL `user`")
	flag.StringVar(&cfg.db.Pass, "db.pass", def.DBPass, "PostgreSQL `pass`")
	flag.StringVar(&cfg.db.DBName, "db.name", def.DBName, "PostgreSQL `dbname`")
	flag.BoolVar(&cfg.resetDB, "db.reset", def.ResetDB, "reset database if true")

	flag.StringVar(&cfg.api.Host, "api.host", def.APIHost, "serve API on `host`")
	flag.IntVar(&cfg.api.Port, "api.port", def.APIPort, "serve API on `port` (>0)")
	flag.StringVar(&cfg.api.BasePath, "api.basepath", def.APIBasePath, "serve API on `path`")
	flag.StringVar(&cfg.api.AllowedOrigins, "api.allow-origins", def.CORSAllowedOrigins, "frontend url")

	flag.StringVar(&cfg.extauthEndpoint, ExtauthEndpointFlag, def.ExtauthEndpoint, "extauth service `endpoint`")

}

func main() {
	flag.Parse()
	structlog.DefaultLogger.SetLogLevel(structlog.ParseLevel(cfg.logLevel))

	var err error
	errc := make(chan error)
	go runServe(errc)
	err = <-errc
	if err != nil {
		log.Fatal(err)
	}
}

func connect() (app.App, *extauthapi.Client, error) {
	ctx, cancel := context.WithTimeout(context.Background(), connectTimeout)
	defer cancel()

	extAuthSvc, err := extauthapi.NewClient(cfg.extauthEndpoint, &tls.Config{InsecureSkipVerify: true}, false)
	if err != nil {
		return nil, nil, fmt.Errorf("extauthapi: %v. Error can be if flag '%s' or environment variable '%s' is not set", err, ExtauthEndpointFlag, def.ExtauthEndpointEnvName)
	}

	r, err := dal.New(ctx, cfg.db, cfg.gooseDir, cfg.resetDB)
	if err != nil {
		return nil, nil, err
	}

	rulesSet := authorization.NewRulesSet()

	app := app.New(r, rulesSet)
	return app, extAuthSvc, nil
}

func runServe(errc chan<- error) {
	log.Info("server started")
	defer log.Info("server finished")

	appl, extAuthSvc, err := connect()
	if err != nil {
		errc <- err
		return
	}

	srv, err := api.NewServer(appl, extAuthSvc, cfg.api)
	if err != nil {
		errc <- fmt.Errorf("api: %v", err)
		return
	}

	errc <- srv.Serve()
}
