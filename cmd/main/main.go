// Code generated by mtgroup-generator.
package main

import (
	"context"
	"flag"
	"fmt"
	"time"
	"wash-bonus/internal/app/user"
	"wash-bonus/internal/app/wash_server"
	"wash-bonus/internal/dal"
	"wash-bonus/internal/firebase_auth"

	"wash-bonus/internal/api"
	"wash-bonus/internal/app"
	"wash-bonus/internal/def"

	"github.com/powerman/pqx"
	"github.com/powerman/structlog"
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

const (
	connectTimeout = 3 * time.Second
)

var (
	testRepo *dal.Repo
	testAppl app.App

	log = structlog.New()
	cfg struct {
		logLevel string
		gooseDir string
		db       pqx.Config
		api      api.Config
		resetDB  bool
	}
)

func init() {
	var dbSSLModeRequire bool

	flag.BoolVar(&dbSSLModeRequire, "db.ssl-mode-is-req", def.DBSSLModeIsReq, "PostgreSQL SSL mode")

	if dbSSLModeRequire {
		cfg.db.SSLMode = pqx.SSLRequire
	} else {
		cfg.db.SSLMode = pqx.SSLDisable
	}
	flag.StringVar(&cfg.logLevel, "log.level", "debug", "log `level` (debug|info|warn|err)")

	flag.StringVar(&cfg.gooseDir, "goose.dir", def.GooseDir, "goose migrations `dir`")
	flag.StringVar(&cfg.db.Host, "db.host", def.DBHost, "PostgreSQL `host`")
	flag.IntVar(&cfg.db.Port, "db.port", def.DBPort, "PostgreSQL `port`")
	flag.StringVar(&cfg.db.User, "db.user", def.DBUser, "PostgreSQL `user`")
	flag.StringVar(&cfg.db.Pass, "db.pass", def.DBPass, "PostgreSQL `pass`")
	flag.StringVar(&cfg.db.DBName, "db.name", def.DBName, "PostgreSQL `dbname`")
	flag.BoolVar(&cfg.resetDB, "db.reset", def.ResetDB, "reset database if true")

	flag.StringVar(&cfg.api.Host, "api.host", def.APIHost, "serve API on `host`")
	flag.IntVar(&cfg.api.Port, "api.port", def.APIPort, "serve API on `port` (>0)")
	flag.StringVar(&cfg.api.BasePath, "api.basepath", def.APIBasePath, "serve API on `path`")
	flag.StringVar(&cfg.api.AllowedOrigins, "api.allow-origins", def.CORSAllowedOrigins, "frontend url")

}

func main() {
	flag.Parse()
	structlog.DefaultLogger.SetLogLevel(structlog.ParseLevel(cfg.logLevel))

	var err error
	errc := make(chan error)
	go runServe(errc)
	err = <-errc
	if err != nil {
		log.Fatal(err)
	}
}

func initDal() (*dal.Repo, error) {
	ctx, cancel := context.WithTimeout(context.Background(), connectTimeout)
	defer cancel()

	r, err := dal.New(ctx, cfg.db, cfg.gooseDir, cfg.resetDB)
	if err != nil {
		return nil, err
	}

	return r, nil
}

func runServe(errc chan<- error) {
	log.Info("server started")
	defer log.Info("server finished")

	r, err := initDal()
	if err != nil {
		errc <- err
		return
	}
	appl := app.New(r)
	userSvc := user.NewService(r)
	washServerSvc, err := wash_server.NewService(r, userSvc, def.WashServerRSAKeyFilePath)
	if err != nil {
		errc <- err
		return
	}

	firebase := firebase_auth.New(def.FirebaseKeyFilePath)

	srv, err := api.NewServer(appl, userSvc, washServerSvc, cfg.api, firebase)
	if err != nil {
		errc <- fmt.Errorf("api: %v", err)
		return
	}

	errc <- srv.Serve()
}
