// Code generated by mtgroup-generator.
package dal

import (
	"database/sql"
	"strings"
	"time"

	"github.com/google/uuid"
	"wash-bonus/internal/app"
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

type Token struct {
	ID           uuid.UUID      `db:"id"`
	ExpirationAt *time.Time     `db:"expiration_at"`
	Token        sql.NullString `db:"token"`
	Type         sql.NullString `db:"type"`
}

var TokenProps = map[string]columnProps{
	"expirationAt": {
		sqlName:  "expiration_at",
		typeName: "date-time",
	},
	"id": {
		sqlName:  "id",
		typeName: "uuid",
	},
	"token": {
		sqlName:  "token",
		typeName: "string",
	},
	"type": {
		sqlName:  "type",
		typeName: "string",
	},
}

func (a *Repo) GetToken(id string, isolatedEntityID string) (*app.Token, error) {
	return a.getToken(id, isolatedEntityID)
}

func (a *Repo) AddToken(profileID string, isolatedEntityID string, m *app.Token) (*app.Token, error) {
	id, err := a.addToken(profileID, isolatedEntityID, m)
	if err != nil {
		return nil, err
	}
	return a.getToken(id, isolatedEntityID)
}

func (a *Repo) DeleteToken(id string, profileID string, isolatedEntityID string) error {
	t := time.Now()
	res, err := a.db.NamedExec(sqlDeleteToken, argDeleteToken{
		ID:               id,
		DeletedAt:        &t,
		DeletedBy:        profileID,
		IsolatedEntityID: isolatedEntityID,
	})
	if err != nil {
		return err
	}
	if count, _ := res.RowsAffected(); count == 0 {
		return app.ErrNotFound
	}

	return nil
}

func (a *Repo) getToken(id string, isolatedEntityID string) (*app.Token, error) {
	var m Token
	if err := a.db.NamedGet(&m, sqlGetToken, argGetToken{
		ID:               newNullUUID(id),
		IsolatedEntityID: isolatedEntityID,
	}); err != nil {
		if err == sql.ErrNoRows {
			return nil, app.ErrNotFound
		}
		return nil, err
	}
	return appToken(m), nil
}

func (a *Repo) addToken(profileID string, isolatedEntityID string, m *app.Token) (string, error) {
	TokenID := uuid.New().String()
	if err := a.db.NamedGet(&TokenID, sqlAddToken, argAddToken{
		ID:               TokenID,
		ExpirationAt:     m.ExpirationAt,
		Token:            m.Token,
		Type:             m.Type,
		CreatedBy:        profileID,
		IsolatedEntityID: isolatedEntityID,
	}); err != nil {
		if strings.Contains(err.Error(), "duplicate key value violates unique constraint") {
			return "", app.ErrDuplicateID
		}
		return "", err
	}
	return TokenID, nil
}

func (a *Repo) getMyTokenID(profileID, isolatedEntityID string) (id string, err error) {
	if err = a.db.NamedGet(&id, sqlGetMyTokenID, argGetMyTokenID{
		CreatedBy:        profileID,
		IsolatedEntityID: isolatedEntityID,
	}); err != nil {
		if err == sql.ErrNoRows {
			return "", app.ErrNotFound
		}
		return
	}
	return
}

func (a *Repo) bindToProfileToken(id, profileID, isolatedEntityID string) error {
	res, err := a.db.NamedExec(sqlBindTokenToProfile, argBindTokenToProfile{
		ID:               id,
		CreatedBy:        profileID,
		IsolatedEntityID: isolatedEntityID,
	})
	if err != nil {
		return err
	}

	if count, _ := res.RowsAffected(); count == 0 {
		return app.ErrNotFound
	}
	return nil
}

func (a *Repo) editToken(id string, isolatedEntityID string, m *app.Token) error {

	res, err := a.db.NamedExec(sqlEditToken, argEditToken{
		ID:               id,
		ExpirationAt:     m.ExpirationAt,
		Token:            m.Token,
		Type:             m.Type,
		IsolatedEntityID: isolatedEntityID,
	})
	if err != nil {
		return err
	}

	if count, _ := res.RowsAffected(); count == 0 {
		return app.ErrNotFound
	}

	return nil
}

func (m *Token) Filter(key string, filter *app.Filter) (ok bool, err error) {
	columnType := TokenProps[key].typeName
	if err = validateOperator(filter.Operator, columnType); err != nil {
		return true, err
	}
	if err = vaidateIgnoreCase(filter.IgnoreCase, columnType); err != nil {
		return true, err
	}
	if err := validateValue(filter.Value, columnType); err != nil {
		return true, err
	}
	switch key {
	case "id":
		ok = compareUUID(filter.Operator, m.ID, filter.Value)
	case "expirationAt":
		ok = compareTime(filter.Operator, *m.ExpirationAt, filter.Value)
	case "token":
		ok = compareString(filter.Operator, filter.IgnoreCase, m.Token.String, filter.Value)
	case "type":
		ok = compareString(filter.Operator, filter.IgnoreCase, m.Type.String, filter.Value)
	default:
		ok, err = true, errNotExistFilterKey
	}
	return
}

func appToken(m Token) *app.Token {
	if m.ID.String() == "00000000-0000-0000-0000-000000000000" {
		return nil
	}
	return &app.Token{
		ID:           m.ID.String(),
		ExpirationAt: m.ExpirationAt,
		Token:        m.Token.String,
		Type:         m.Type.String,
	}
}

func appTokens(ms []Token) []*app.Token {
	ams := []*app.Token{}
	for _, m := range ms {
		ams = append(ams, appToken(m))
	}

	return ams
}
