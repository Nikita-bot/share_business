// Code generated by mtgroup-generator.
package dal

import (
	"database/sql"
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"
	"wash-bonus/internal/app"
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

type WashSession struct {
	ID           uuid.UUID      `db:"id"`
	Active       sql.NullBool   `db:"active"`
	ClosingAt    *time.Time     `db:"closing_at"`
	CreatedAt    *time.Time     `db:"created_at"`
	ExpirationAt *time.Time     `db:"expiration_at"`
	UpdateAt     *time.Time     `db:"update_at"`
	UserID       sql.NullString `db:"user_id"`
	User         Token
	WashServerID sql.NullString `db:"wash_server_id"`
	WashServer   WashServer
}

var WashSessionProps = map[string]columnProps{
	"active": {
		sqlName:  "active",
		typeName: "bool",
	},
	"closingAt": {
		sqlName:  "closing_at",
		typeName: "date-time",
	},
	"createdAt": {
		sqlName:  "created_at",
		typeName: "date-time",
	},
	"expirationAt": {
		sqlName:  "expiration_at",
		typeName: "date-time",
	},
	"id": {
		sqlName:  "id",
		typeName: "uuid",
	},
	"updateAt": {
		sqlName:  "update_at",
		typeName: "date-time",
	},
	"user": {
		sqlName:  "user_id",
		typeName: "uuid",
	},
	"washServer": {
		sqlName:  "wash_server_id",
		typeName: "uuid",
	},
}

func (a *Repo) GetWashSession(id string, isolatedEntityID string) (*app.WashSession, error) {
	return a.getWashSession(id, isolatedEntityID)
}

func (a *Repo) AddWashSession(profileID string, isolatedEntityID string, m *app.WashSession) (*app.WashSession, error) {
	id, err := a.addWashSession(profileID, isolatedEntityID, m)
	if err != nil {
		return nil, err
	}
	return a.getWashSession(id, isolatedEntityID)
}

func (a *Repo) EditWashSession(id string, isolatedEntityID string, m *app.WashSession) error {
	if err := a.editWashSession(id, isolatedEntityID, m); err != nil {
		return err
	}

	return nil
}

func (a *Repo) DeleteWashSession(id string, profileID string, isolatedEntityID string) error {
	t := time.Now()
	res, err := a.db.NamedExec(sqlDeleteWashSession, argDeleteWashSession{
		ID:               id,
		DeletedAt:        &t,
		DeletedBy:        profileID,
		IsolatedEntityID: isolatedEntityID,
	})
	if err != nil {
		return err
	}
	if count, _ := res.RowsAffected(); count == 0 {
		return app.ErrNotFound
	}

	return nil
}

func (a *Repo) ListWashSession(isolatedEntityID string, params *app.ListParams) ([]*app.WashSession, []string, error) {
	ms := []WashSession{}
	warnings := []string{}

	var orderQuery string
	switch params.SortBy {
	case "":
	default:
		warnings = append(warnings, fmt.Sprintf("Sorting by '%s' is not avaliable or '%s' is not a valid sort key", params.SortBy, params.SortBy))
	}

	if orderQuery != "" {
		switch params.OrderBy {
		case "ASC", "":
			orderQuery += " ASC"
		case "DESC":
			orderQuery += " DESC"
		}
	}

	bf := newBuilderFilter(params.FilterGroups, WashSessionProps)

	sqlFilters, namedVars, warningsFromPrepared := bf.preparedSQLFilters()
	warnings = append(warnings, warningsFromPrepared...)

	namedVars["isolated_entity_id"] = isolatedEntityID

	var offset, limit string
	var err error

	nestedFilterGroups := bf.nestedFilterGroups()

	externalPagination := false
	if len(nestedFilterGroups) != 0 {
		externalPagination = true
	}
	if !externalPagination {
		offset = " OFFSET :offset"
		namedVars["offset"] = params.Offset
		if params.Limit != 0 {
			limit = " LIMIT :limit"
			namedVars["limit"] = params.Limit
		}
	}

	err = a.db.NamedSelect(&ms, sqlListWashSession+sqlFilters+orderQuery+offset+limit, namedVars)
	if err != nil {
		return nil, nil, err
	}

	result := []WashSession{}
	for i := range ms {
		if err := ms[i].LazyLoading(isolatedEntityID, a); err != nil {
			return nil, nil, err
		}

		ok := true
		for j, filterGroup := range nestedFilterGroups {
			for _, filter := range filterGroup.Filters {
				var validFilter error
				ok, validFilter = ms[i].NestedFilter(filterGroup.Key, filter)
				if validFilter != nil {
					warnings = append(warnings, fmt.Sprintf("Filter key: '%s'. Error: %s", filterGroup.Key, validFilter.Error()))
					nestedFilterGroups = append(nestedFilterGroups[:j], nestedFilterGroups[j+1:]...)
					j--
				}
				if (!ok && filterGroup.LogicFilter) || (ok && !filterGroup.LogicFilter) {
					break
				}
			}
		}
		if ok {
			result = append(result, ms[i])
		}
	}

	if externalPagination {
		start, end := pagination(int(params.Offset), int(params.Limit), len(result))
		result = result[start:end]
	}

	return appWashSessions(result), warnings, nil
}

func (m *WashSession) LazyLoading(isolatedEntityID string, a *Repo) (err error) {
	if err = a.db.NamedGet(&m.User, sqlGetUserForWashSessionLazyLoading, argGetToken{
		ID:               m.UserID,
		IsolatedEntityID: isolatedEntityID,
	}); err != nil && err != sql.ErrNoRows {
		return
	}
	if err = a.db.NamedGet(&m.WashServer, sqlGetWashServerForWashSessionLazyLoading, argGetWashServer{
		ID:               m.WashServerID,
		IsolatedEntityID: isolatedEntityID,
	}); err != nil && err != sql.ErrNoRows {
		return
	}
	return nil
}

func (a *Repo) getWashSession(id string, isolatedEntityID string) (*app.WashSession, error) {
	var m WashSession
	if err := a.db.NamedGet(&m, sqlGetWashSession, argGetWashSession{
		ID:               newNullUUID(id),
		IsolatedEntityID: isolatedEntityID,
	}); err != nil {
		if err == sql.ErrNoRows {
			return nil, app.ErrNotFound
		}
		return nil, err
	}
	if err := m.LazyLoading(isolatedEntityID, a); err != nil {
		return nil, err
	}
	return appWashSession(m), nil
}

func (a *Repo) addWashSession(profileID string, isolatedEntityID string, m *app.WashSession) (string, error) {
	WashSessionID := uuid.New().String()
	t := time.Now()
	m.CreatedAt = &t
	var userID interface{}
	if m.User != nil {
		userID = m.User.ID
	}
	var washServerID interface{}
	if m.WashServer != nil {
		washServerID = m.WashServer.ID
	}
	if err := a.db.NamedGet(&WashSessionID, sqlAddWashSession, argAddWashSession{
		ID:               WashSessionID,
		Active:           m.Active,
		ClosingAt:        m.ClosingAt,
		CreatedAt:        m.CreatedAt,
		ExpirationAt:     m.ExpirationAt,
		UpdateAt:         m.UpdateAt,
		UserID:           userID,
		WashServerID:     washServerID,
		CreatedBy:        profileID,
		IsolatedEntityID: isolatedEntityID,
	}); err != nil {
		if strings.Contains(err.Error(), "duplicate key value violates unique constraint") {
			return "", app.ErrDuplicateID
		}
		return "", err
	}
	return WashSessionID, nil
}

func (a *Repo) getMyWashSessionID(profileID, isolatedEntityID string) (id string, err error) {
	if err = a.db.NamedGet(&id, sqlGetMyWashSessionID, argGetMyWashSessionID{
		CreatedBy:        profileID,
		IsolatedEntityID: isolatedEntityID,
	}); err != nil {
		if err == sql.ErrNoRows {
			return "", app.ErrNotFound
		}
		return
	}
	return
}

func (a *Repo) bindToProfileWashSession(id, profileID, isolatedEntityID string) error {
	res, err := a.db.NamedExec(sqlBindWashSessionToProfile, argBindWashSessionToProfile{
		ID:               id,
		CreatedBy:        profileID,
		IsolatedEntityID: isolatedEntityID,
	})
	if err != nil {
		return err
	}

	if count, _ := res.RowsAffected(); count == 0 {
		return app.ErrNotFound
	}
	return nil
}

func (a *Repo) editWashSession(id string, isolatedEntityID string, m *app.WashSession) error {
	var userID interface{}
	if m.User != nil {
		userID = m.User.ID
	}
	var washServerID interface{}
	if m.WashServer != nil {
		washServerID = m.WashServer.ID
	}

	res, err := a.db.NamedExec(sqlEditWashSession, argEditWashSession{
		ID:               id,
		Active:           m.Active,
		ClosingAt:        m.ClosingAt,
		CreatedAt:        m.CreatedAt,
		ExpirationAt:     m.ExpirationAt,
		UpdateAt:         m.UpdateAt,
		UserID:           userID,
		WashServerID:     washServerID,
		IsolatedEntityID: isolatedEntityID,
	})
	if err != nil {
		return err
	}

	if count, _ := res.RowsAffected(); count == 0 {
		return app.ErrNotFound
	}

	return nil
}
func (m *WashSession) NestedFilter(key string, filter *app.Filter) (ok bool, err error) {
	if strings.Contains(key, ".") {
		splitedFilter := strings.SplitN(key, ".", 2)
		key = splitedFilter[1]
		switch splitedFilter[0] {
		case "user":
			ok, err = m.User.Filter(key, filter)
		case "washServer":
			ok, err = m.WashServer.Filter(key, filter)
		default:
			ok, err = true, errNotExistFilterKey
		}
	} else {
		ok, err = m.Filter(key, filter)
	}
	return
}

func (m *WashSession) Filter(key string, filter *app.Filter) (ok bool, err error) {
	columnType := WashSessionProps[key].typeName
	if err = validateOperator(filter.Operator, columnType); err != nil {
		return true, err
	}
	if err = vaidateIgnoreCase(filter.IgnoreCase, columnType); err != nil {
		return true, err
	}
	if err := validateValue(filter.Value, columnType); err != nil {
		return true, err
	}
	switch key {
	case "id":
		ok = compareUUID(filter.Operator, m.ID, filter.Value)
	case "active":
		ok = compareBool(filter.Operator, m.Active.Bool, filter.Value)
	case "closingAt":
		ok = compareTime(filter.Operator, *m.ClosingAt, filter.Value)
	case "createdAt":
		ok = compareTime(filter.Operator, *m.CreatedAt, filter.Value)
	case "expirationAt":
		ok = compareTime(filter.Operator, *m.ExpirationAt, filter.Value)
	case "updateAt":
		ok = compareTime(filter.Operator, *m.UpdateAt, filter.Value)
	default:
		ok, err = true, errNotExistFilterKey
	}
	return
}

func appWashSession(m WashSession) *app.WashSession {
	if m.ID.String() == "00000000-0000-0000-0000-000000000000" {
		return nil
	}
	return &app.WashSession{
		ID:           m.ID.String(),
		Active:       m.Active.Bool,
		ClosingAt:    m.ClosingAt,
		CreatedAt:    m.CreatedAt,
		ExpirationAt: m.ExpirationAt,
		UpdateAt:     m.UpdateAt,
		User:         appToken(m.User),
		WashServer:   appWashServer(m.WashServer),
	}
}

func appWashSessions(ms []WashSession) []*app.WashSession {
	ams := []*app.WashSession{}
	for _, m := range ms {
		ams = append(ams, appWashSession(m))
	}

	return ams
}
