// Code generated by mtgroup-generator.
package dal

import (
	"database/sql"
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"
	"wash-bonus/internal/app"
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

type WashServer struct {
	ID           uuid.UUID      `db:"id"`
	CreatedAt    *time.Time     `db:"created_at"`
	Key          sql.NullString `db:"key"`
	LastUpdateAt *time.Time     `db:"last_update_at"`
	ModifiedAt   *time.Time     `db:"modified_at"`
	Name         sql.NullString `db:"name"`
}

var WashServerProps = map[string]columnProps{
	"createdAt": {
		sqlName:  "created_at",
		typeName: "date-time",
	},
	"id": {
		sqlName:  "id",
		typeName: "uuid",
	},
	"key": {
		sqlName:  "key",
		typeName: "string",
	},
	"lastUpdateAt": {
		sqlName:  "last_update_at",
		typeName: "date-time",
	},
	"modifiedAt": {
		sqlName:  "modified_at",
		typeName: "date-time",
	},
	"name": {
		sqlName:  "name",
		typeName: "string",
	},
}

func (a *Repo) GetWashServer(id string, isolatedEntityID string) (*app.WashServer, error) {
	return a.getWashServer(id, isolatedEntityID)
}

func (a *Repo) AddWashServer(profileID string, isolatedEntityID string, m *app.WashServer) (*app.WashServer, error) {
	id, err := a.addWashServer(profileID, isolatedEntityID, m)
	if err != nil {
		return nil, err
	}
	return a.getWashServer(id, isolatedEntityID)
}

func (a *Repo) EditWashServer(id string, isolatedEntityID string, m *app.WashServer) error {
	if err := a.editWashServer(id, isolatedEntityID, m); err != nil {
		return err
	}

	return nil
}

func (a *Repo) DeleteWashServer(id string, profileID string, isolatedEntityID string) error {
	t := time.Now()
	res, err := a.db.NamedExec(sqlDeleteWashServer, argDeleteWashServer{
		ID:               id,
		DeletedAt:        &t,
		DeletedBy:        profileID,
		IsolatedEntityID: isolatedEntityID,
	})
	if err != nil {
		return err
	}
	if count, _ := res.RowsAffected(); count == 0 {
		return app.ErrNotFound
	}

	return nil
}

func (a *Repo) ListWashServer(isolatedEntityID string, params *app.ListParams) ([]*app.WashServer, []string, error) {
	ms := []WashServer{}
	warnings := []string{}

	var orderQuery string
	switch params.SortBy {
	case "":
	default:
		warnings = append(warnings, fmt.Sprintf("Sorting by '%s' is not avaliable or '%s' is not a valid sort key", params.SortBy, params.SortBy))
	}

	if orderQuery != "" {
		switch params.OrderBy {
		case "ASC", "":
			orderQuery += " ASC"
		case "DESC":
			orderQuery += " DESC"
		}
	}

	bf := newBuilderFilter(params.FilterGroups, WashServerProps)

	sqlFilters, namedVars, warningsFromPrepared := bf.preparedSQLFilters()
	warnings = append(warnings, warningsFromPrepared...)

	namedVars["isolated_entity_id"] = isolatedEntityID

	var offset, limit string
	var err error

	offset = " OFFSET :offset"
	namedVars["offset"] = params.Offset
	if params.Limit != 0 {
		limit = " LIMIT :limit"
		namedVars["limit"] = params.Limit
	}

	err = a.db.NamedSelect(&ms, sqlListWashServer+sqlFilters+orderQuery+offset+limit, namedVars)
	if err != nil {
		return nil, nil, err
	}

	result := ms

	return appWashServers(result), warnings, nil
}

func (a *Repo) getWashServer(id string, isolatedEntityID string) (*app.WashServer, error) {
	var m WashServer
	if err := a.db.NamedGet(&m, sqlGetWashServer, argGetWashServer{
		ID:               newNullUUID(id),
		IsolatedEntityID: isolatedEntityID,
	}); err != nil {
		if err == sql.ErrNoRows {
			return nil, app.ErrNotFound
		}
		return nil, err
	}
	return appWashServer(m), nil
}

func (a *Repo) addWashServer(profileID string, isolatedEntityID string, m *app.WashServer) (string, error) {
	WashServerID := uuid.New().String()
	t := time.Now()
	m.CreatedAt = &t
	if err := a.db.NamedGet(&WashServerID, sqlAddWashServer, argAddWashServer{
		ID:               WashServerID,
		CreatedAt:        m.CreatedAt,
		Key:              m.Key,
		LastUpdateAt:     m.LastUpdateAt,
		Name:             m.Name,
		CreatedBy:        profileID,
		IsolatedEntityID: isolatedEntityID,
	}); err != nil {
		if strings.Contains(err.Error(), "duplicate key value violates unique constraint") {
			return "", app.ErrDuplicateID
		}
		return "", err
	}
	return WashServerID, nil
}

func (a *Repo) getMyWashServerID(profileID, isolatedEntityID string) (id string, err error) {
	if err = a.db.NamedGet(&id, sqlGetMyWashServerID, argGetMyWashServerID{
		CreatedBy:        profileID,
		IsolatedEntityID: isolatedEntityID,
	}); err != nil {
		if err == sql.ErrNoRows {
			return "", app.ErrNotFound
		}
		return
	}
	return
}

func (a *Repo) bindToProfileWashServer(id, profileID, isolatedEntityID string) error {
	res, err := a.db.NamedExec(sqlBindWashServerToProfile, argBindWashServerToProfile{
		ID:               id,
		CreatedBy:        profileID,
		IsolatedEntityID: isolatedEntityID,
	})
	if err != nil {
		return err
	}

	if count, _ := res.RowsAffected(); count == 0 {
		return app.ErrNotFound
	}
	return nil
}

func (a *Repo) editWashServer(id string, isolatedEntityID string, m *app.WashServer) error {
	t := time.Now()
	m.ModifiedAt = &t

	res, err := a.db.NamedExec(sqlEditWashServer, argEditWashServer{
		ID:               id,
		CreatedAt:        m.CreatedAt,
		Key:              m.Key,
		LastUpdateAt:     m.LastUpdateAt,
		ModifiedAt:       m.ModifiedAt,
		Name:             m.Name,
		IsolatedEntityID: isolatedEntityID,
	})
	if err != nil {
		return err
	}

	if count, _ := res.RowsAffected(); count == 0 {
		return app.ErrNotFound
	}

	return nil
}

func (m *WashServer) Filter(key string, filter *app.Filter) (ok bool, err error) {
	columnType := WashServerProps[key].typeName
	if err = validateOperator(filter.Operator, columnType); err != nil {
		return true, err
	}
	if err = vaidateIgnoreCase(filter.IgnoreCase, columnType); err != nil {
		return true, err
	}
	if err := validateValue(filter.Value, columnType); err != nil {
		return true, err
	}
	switch key {
	case "id":
		ok = compareUUID(filter.Operator, m.ID, filter.Value)
	case "createdAt":
		ok = compareTime(filter.Operator, *m.CreatedAt, filter.Value)
	case "key":
		ok = compareString(filter.Operator, filter.IgnoreCase, m.Key.String, filter.Value)
	case "lastUpdateAt":
		ok = compareTime(filter.Operator, *m.LastUpdateAt, filter.Value)
	case "modifiedAt":
		ok = compareTime(filter.Operator, *m.ModifiedAt, filter.Value)
	case "name":
		ok = compareString(filter.Operator, filter.IgnoreCase, m.Name.String, filter.Value)
	default:
		ok, err = true, errNotExistFilterKey
	}
	return
}

func appWashServer(m WashServer) *app.WashServer {
	if m.ID.String() == "00000000-0000-0000-0000-000000000000" {
		return nil
	}
	return &app.WashServer{
		ID:           m.ID.String(),
		CreatedAt:    m.CreatedAt,
		Key:          m.Key.String,
		LastUpdateAt: m.LastUpdateAt,
		ModifiedAt:   m.ModifiedAt,
		Name:         m.Name.String,
	}
}

func appWashServers(ms []WashServer) []*app.WashServer {
	ams := []*app.WashServer{}
	for _, m := range ms {
		ams = append(ams, appWashServer(m))
	}

	return ams
}
