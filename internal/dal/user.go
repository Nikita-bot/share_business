// Code generated by mtgroup-generator.
package dal

import (
	"database/sql"
	uuid "github.com/satori/go.uuid"
	"time"
	"wash-bonus/internal/app"
	"wash-bonus/internal/app/entity"
	"wash-bonus/internal/app/entity/vo"
	"wash-bonus/internal/dal/dbmodel"
	"wash-bonus/internal/dto"
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

func (r *Repo) GetUserByIdentityID(identityID string) (*entity.User, error) {
	var m dbmodel.User

	err := r.db.NamedGet(&m, sqlGetUserByIdentity, argGetUserByIdentity{
		IdentityID: identityID,
	})

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, app.ErrNotFound
		}
		return nil, err
	}

	user := dto.UserFromDB(m)
	return &user, nil
}

func (r *Repo) GetUser(id string) (*entity.User, error) {
	var m dbmodel.User

	err := r.db.NamedGet(&m, sqlGetUser, argGetUser{
		ID: id,
	})

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, err
	}

	user := dto.UserFromDB(m)
	return &user, nil
}

func (r *Repo) AddUser(u entity.User) error {
	_, err := r.db.NamedExec(sqlAddUser, argAddUser{
		Active:     u.Active,
		CreatedAt:  u.CreatedAt,
		IdentityID: u.IdentityID,
	})

	if err != nil {
		return err
	}

	return nil
}

func (r *Repo) EditUser(id string, update vo.UserUpdate, editedBy entity.User) error {
	t := time.Now()

	res, err := r.db.NamedExec(sqlEditUser, argEditUser{
		ID:     id,
		Active: update.Active,

		ModifiedAt: &t,
		ModifiedBy: uuid.NullUUID{UUID: editedBy.ID, Valid: true},
	})
	if err != nil {
		return err
	}

	if count, _ := res.RowsAffected(); count == 0 {
		return app.ErrNotFound
	}

	return nil
}

func (r *Repo) DeleteUser(id string, deletedBy entity.User) error {
	t := time.Now()
	res, err := r.db.NamedExec(sqlDeleteUser, argDeleteUser{
		ID:        id,
		DeletedAt: t,
		DeletedBy: uuid.NullUUID{
			UUID:  deletedBy.ID,
			Valid: true,
		},
	})
	if err != nil {
		return err
	}
	if count, _ := res.RowsAffected(); count == 0 {
		return app.ErrNotFound
	}

	return nil
}

// TODO: Build sql with filters and pagination
func (r *Repo) ListUsers(filter vo.ListFilter) ([]entity.User, []string, error) {
	ms := []dbmodel.User{}
	warnings := []string{}

	err := r.db.NamedSelect(&ms, sqlListUser, nil)
	if err != nil {
		return nil, nil, err
	}

	result := []dbmodel.User{}

	return dto.UsersFromDB(result), warnings, nil
}
