
// Code generated by mtgroup-generator.
package dal

import (
	"database/sql"
	"strings"
	"time"
	"fmt"

	"wash-bonus/internal/app"
	"github.com/google/uuid"
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

type Role struct {
				ID uuid.UUID `db:"id"`
				Active sql.NullBool `db:"active"`
				Name sql.NullString `db:"name"`
		Permissions []Permission
}

var RoleProps = map[string]columnProps{
		"active": {
			sqlName:  "active",
			typeName: "bool",
		},
		"id": {
			sqlName:  "id",
			typeName: "uuid",
		},
		"name": {
			sqlName:  "name",
			typeName: "string",
		},
		"permissions": {
			sqlName:  "permissions",
			typeName: "uuid",
				isArray: true,
		},
}
	func (a *Repo) GetRole(id string, isolatedEntityID string) (*app.Role, error) {
			return a.getRole(id, isolatedEntityID)
	}

	func (a *Repo) AddRole(profileID string, isolatedEntityID string, m *app.Role) (*app.Role, error) {
		id, err := a.addRole(profileID, isolatedEntityID, m)
		if err != nil {
			return nil, err
		}
		return a.getRole(id, isolatedEntityID)
	}

	func (a *Repo) EditRole(id string, isolatedEntityID string, m *app.Role) error  {
			if err := a.editRole(id, isolatedEntityID, m); err != nil {
				return err
			}
		

		return nil
	}

	func (a *Repo) DeleteRole(id string, profileID string, isolatedEntityID string) error {
		t := time.Now()
		res, err := a.db.NamedExec(sqlDeleteRole, argDeleteRole{
			ID: id,
			DeletedAt: &t,
			DeletedBy: profileID,
				IsolatedEntityID: isolatedEntityID,
		})
		if err != nil {
			return err
		}
		if count, _ := res.RowsAffected(); count == 0 {
			return app.ErrNotFound
		}
		
		return nil
	}

	func (a *Repo) ListRole(isolatedEntityID string, params *app.ListParams) ([]*app.Role, []string, error) { 
		ms := []Role{}
		warnings := []string{}

		var orderQuery string
		switch params.SortBy {
			case "":
			default:
				warnings = append(warnings, fmt.Sprintf("Sorting by '%s' is not avaliable or '%s' is not a valid sort key", params.SortBy, params.SortBy))
		}

		if orderQuery != "" {
			switch params.OrderBy {
			case "ASC", "":
				orderQuery += " ASC"
			case "DESC":
				orderQuery += " DESC"
			}
		}

		bf := newBuilderFilter(params.FilterGroups, RoleProps)

		sqlFilters, namedVars, warningsFromPrepared := bf.preparedSQLFilters()
		warnings = append(warnings, warningsFromPrepared...)

		
			namedVars["isolated_entity_id"] = isolatedEntityID
		

		var offset, limit string
		var err error
		
			nestedFilterGroups := bf.nestedFilterGroups()
			
			externalPagination := false
			if len(nestedFilterGroups) != 0  {
				externalPagination = true
			}
			if !externalPagination {
				offset = " OFFSET :offset"
				namedVars["offset"] = params.Offset
				if params.Limit != 0 {
					limit = " LIMIT :limit"
					namedVars["limit"] = params.Limit
				}
			}
		
		
		err = a.db.NamedSelect(&ms, sqlListRole+sqlFilters+orderQuery+offset+limit, namedVars)
		if err != nil {
			return nil, nil, err
		}
		
		result := []Role{}
				for i := range ms {
					if err := ms[i].LazyLoading(isolatedEntityID, a); err != nil {
						return nil, nil, err
					}

					ok := true 
					for j, filterGroup := range nestedFilterGroups {
						for _, filter := range filterGroup.Filters {
							var validFilter error
								ok, validFilter = ms[i].NestedFilter(filterGroup.Key, filter)
							if validFilter != nil {
								warnings = append(warnings, fmt.Sprintf("Filter key: '%s'. Error: %s", filterGroup.Key, validFilter.Error()))
								nestedFilterGroups = append(nestedFilterGroups[:j], nestedFilterGroups[j+1:]...)
								j--
							}
							if (!ok && filterGroup.LogicFilter) || (ok && !filterGroup.LogicFilter) {
								break
							}
						}
					}
					if ok {
						result = append(result, ms[i])
					}
				}

		
			if externalPagination {
				start, end := pagination(int(params.Offset), int(params.Limit), len(result))
				result = result[start:end]
			}
		

		return appRoles(result), warnings, nil
	}

func (m *Role) LazyLoading(isolatedEntityID string, a *Repo) (err error) {
				slicePermissions := []RolePermission{}
				if err = a.db.NamedSelect(&slicePermissions, sqlGetPermissionsIDsForRoleLazyLoading, argGetRole{
					ID: newNullUUID(m.ID.String()),
						IsolatedEntityID: isolatedEntityID,
				}); err != nil {
					return
				}
				for _, cd := range slicePermissions {
					var permissions Permission
					if err = a.db.NamedGet(&permissions, sqlGetPermissionsForRoleLazyLoading, argGetPermission{
						ID: newNullUUID(cd.PermissionID.String()),
							IsolatedEntityID: isolatedEntityID,
					}); err != nil {
						return
					}
					m.Permissions = append(m.Permissions, permissions)
				}
	return nil
}
	func (a *Repo) AddPermissionsRole(id string, isolatedEntityID string, itemsID []string, items []*app.Permission) error {
		for _, item := range items {
			id, err := a.addPermission(uuid.New().String(), isolatedEntityID, item)
			if err != nil {
				return err
			}
			itemsID = append(itemsID, id)
		}
		for _, itemID := range itemsID {
			if _, err := a.db.NamedExec(sqlAddToPermissionsInRole, argPermissionsInRole{
				RoleID: id,
				PermissionsID: itemID,
					IsolatedEntityID: isolatedEntityID,
			}); err != nil {
				if strings.Contains(err.Error(), "violates foreign key constraint") {
					switch {
					case strings.Contains(err.Error(), "role_id_fkey"):
						return app.ErrNotFound
					case strings.Contains(err.Error(), "permissions_id_fkey"):
						return app.ErrNotFoundArrayItem
					}
				}
				return err
			}
		}
		return nil
	}

	func (a *Repo) DeletePermissionsRole(id string, isolatedEntityID string, items []string) error {
		for _, item := range items {
			res, err := a.db.NamedExec(sqlDeleteFromPermissionsInRole, argPermissionsInRole{
				RoleID: id,
				PermissionsID: item,
					IsolatedEntityID: isolatedEntityID,
			})
			if err != nil {
				return err
			}
			if count, _ := res.RowsAffected(); count == 0 {
				return app.ErrNotFound
			}
		}
		return nil
	}

func (a *Repo) getRole(id string, isolatedEntityID string) (*app.Role, error) { 
	var m Role
	if err := a.db.NamedGet(&m, sqlGetRole, argGetRole{
		ID: newNullUUID(id),
			IsolatedEntityID: isolatedEntityID, 
	}); err != nil {
		if err == sql.ErrNoRows {
			return nil, app.ErrNotFound
		} 
		return nil, err
	}
		if err := m.LazyLoading(isolatedEntityID, a); err != nil {
			return nil, err
		}
	return appRole(m), nil
}

func (a *Repo) addRole(profileID string, isolatedEntityID string, m *app.Role) (string, error) {
		RoleID := uuid.New().String()
	if err := a.db.NamedGet(&RoleID, sqlAddRole, argAddRole{
			ID: RoleID,
							Active: m.Active,
							Name: m.Name,
			CreatedBy: profileID,
			IsolatedEntityID: isolatedEntityID,
	}); err != nil {
		if strings.Contains(err.Error(), "duplicate key value violates unique constraint") {
			return "", app.ErrDuplicateID
		}
		return "", err
	}
					for _, m := range m.Permissions {
						if _, err := a.db.NamedExec(sqlAddToPermissionsInRole, argPermissionsInRole{
							RoleID: RoleID,
							PermissionsID: m.ID,
								IsolatedEntityID: isolatedEntityID,
						}); err != nil {
							return "", err
						}
					}
	return RoleID, nil
}

func (a *Repo) getMyRoleID(profileID, isolatedEntityID string) (id string, err error) {
	if err = a.db.NamedGet(&id, sqlGetMyRoleID, argGetMyRoleID{
			CreatedBy: profileID,
			IsolatedEntityID: isolatedEntityID,
	}); err != nil {
		if err == sql.ErrNoRows {
			return "", app.ErrNotFound
		}
		return
	}
	return
}

func (a *Repo) bindToProfileRole(id, profileID, isolatedEntityID string) error {
	res, err := a.db.NamedExec(sqlBindRoleToProfile, argBindRoleToProfile{
		ID: id,
			CreatedBy: profileID,
			IsolatedEntityID: isolatedEntityID,
	})
	if err != nil {
		return err
	}

	if count, _ := res.RowsAffected(); count == 0 {
		return app.ErrNotFound
	}
	return nil
}

func (a *Repo) editRole(id string, isolatedEntityID string, m *app.Role) error  {

	res, err := a.db.NamedExec(sqlEditRole, argEditRole{
							ID: id,
							Active: m.Active,
							Name: m.Name,
			IsolatedEntityID: isolatedEntityID,
	})
	if err != nil {
		return err
	}

	if count, _ := res.RowsAffected(); count == 0 {
			return app.ErrNotFound
	}

	return nil
}
func (m *Role) NestedFilter(key string, filter *app.Filter) (ok bool, err error) {
	if strings.Contains(key, ".") {
		splitedFilter := strings.SplitN(key, ".", 2)
		key = splitedFilter[1]
		switch splitedFilter[0] {
			case "permissions":
					for _, elem := range m.Permissions {
						ok, err = elem.Filter(key, filter)
						if ok || err != nil {
							break
						}
					}
		default:
			ok, err = true, errNotExistFilterKey
		}
	} else {
		ok, err = m.Filter(key, filter)
	}
	return
}

func (m *Role) Filter(key string, filter *app.Filter) (ok bool, err error) {
	columnType := RoleProps[key].typeName
	if err = validateOperator(filter.Operator, columnType); err != nil {
		return true, err
	}
	if err = vaidateIgnoreCase(filter.IgnoreCase, columnType); err != nil {
		return true, err
	}
	if err := validateValue(filter.Value, columnType); err != nil {
		return true, err
	}
	switch key {
			case "id":
						ok = compareUUID(filter.Operator, m.ID, filter.Value)
			case "active":
						ok = compareBool(filter.Operator,  m.Active.Bool, filter.Value)
			case "name":
						ok = compareString(filter.Operator, filter.IgnoreCase, m.Name.String, filter.Value)
	default:
		ok, err = true, errNotExistFilterKey
	}
	return
}

func appRole(m Role) *app.Role {
	if m.ID.String() == "00000000-0000-0000-0000-000000000000" {
		return nil
	}
	return &app.Role{
			ID: m.ID.String(),
			Active: m.Active.Bool,
			Name: m.Name.String,
			Permissions: appPermissions(m.Permissions),
	}
}

func appRoles(ms []Role) []*app.Role {
	ams := []*app.Role{}
	for _, m := range ms {
		ams = append(ams, appRole(m))
	}

	return ams
}
