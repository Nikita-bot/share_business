// Code generated by mtgroup-generator.
package dal

import (
	"database/sql"
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"
	"wash-bonus/internal/app"
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

type Permission struct {
	ID   uuid.UUID      `db:"id"`
	Name sql.NullString `db:"name"`
}

var PermissionProps = map[string]columnProps{
	"id": {
		sqlName:  "id",
		typeName: "uuid",
	},
	"name": {
		sqlName:  "name",
		typeName: "string",
	},
}

func (a *Repo) GetPermission(id string, isolatedEntityID string) (*app.Permission, error) {
	return a.getPermission(id, isolatedEntityID)
}

func (a *Repo) AddPermission(profileID string, isolatedEntityID string, m *app.Permission) (*app.Permission, error) {
	id, err := a.addPermission(profileID, isolatedEntityID, m)
	if err != nil {
		return nil, err
	}
	return a.getPermission(id, isolatedEntityID)
}

func (a *Repo) EditPermission(id string, isolatedEntityID string, m *app.Permission) error {
	if err := a.editPermission(id, isolatedEntityID, m); err != nil {
		return err
	}

	return nil
}

func (a *Repo) DeletePermission(id string, profileID string, isolatedEntityID string) error {
	t := time.Now()
	res, err := a.db.NamedExec(sqlDeletePermission, argDeletePermission{
		ID:               id,
		DeletedAt:        &t,
		DeletedBy:        profileID,
		IsolatedEntityID: isolatedEntityID,
	})
	if err != nil {
		return err
	}
	if count, _ := res.RowsAffected(); count == 0 {
		return app.ErrNotFound
	}

	return nil
}

func (a *Repo) ListPermission(isolatedEntityID string, params *app.ListParams) ([]*app.Permission, []string, error) {
	ms := []Permission{}
	warnings := []string{}

	var orderQuery string
	switch params.SortBy {
	case "":
	default:
		warnings = append(warnings, fmt.Sprintf("Sorting by '%s' is not avaliable or '%s' is not a valid sort key", params.SortBy, params.SortBy))
	}

	if orderQuery != "" {
		switch params.OrderBy {
		case "ASC", "":
			orderQuery += " ASC"
		case "DESC":
			orderQuery += " DESC"
		}
	}

	bf := newBuilderFilter(params.FilterGroups, PermissionProps)

	sqlFilters, namedVars, warningsFromPrepared := bf.preparedSQLFilters()
	warnings = append(warnings, warningsFromPrepared...)

	namedVars["isolated_entity_id"] = isolatedEntityID

	var offset, limit string
	var err error

	offset = " OFFSET :offset"
	namedVars["offset"] = params.Offset
	if params.Limit != 0 {
		limit = " LIMIT :limit"
		namedVars["limit"] = params.Limit
	}

	err = a.db.NamedSelect(&ms, sqlListPermission+sqlFilters+orderQuery+offset+limit, namedVars)
	if err != nil {
		return nil, nil, err
	}

	result := ms

	return appPermissions(result), warnings, nil
}

func (a *Repo) getPermission(id string, isolatedEntityID string) (*app.Permission, error) {
	var m Permission
	if err := a.db.NamedGet(&m, sqlGetPermission, argGetPermission{
		ID:               newNullUUID(id),
		IsolatedEntityID: isolatedEntityID,
	}); err != nil {
		if err == sql.ErrNoRows {
			return nil, app.ErrNotFound
		}
		return nil, err
	}
	return appPermission(m), nil
}

func (a *Repo) addPermission(profileID string, isolatedEntityID string, m *app.Permission) (string, error) {
	PermissionID := uuid.New().String()
	if err := a.db.NamedGet(&PermissionID, sqlAddPermission, argAddPermission{
		ID:               PermissionID,
		Name:             m.Name,
		CreatedBy:        profileID,
		IsolatedEntityID: isolatedEntityID,
	}); err != nil {
		if strings.Contains(err.Error(), "duplicate key value violates unique constraint") {
			return "", app.ErrDuplicateID
		}
		return "", err
	}
	return PermissionID, nil
}

func (a *Repo) getMyPermissionID(profileID, isolatedEntityID string) (id string, err error) {
	if err = a.db.NamedGet(&id, sqlGetMyPermissionID, argGetMyPermissionID{
		CreatedBy:        profileID,
		IsolatedEntityID: isolatedEntityID,
	}); err != nil {
		if err == sql.ErrNoRows {
			return "", app.ErrNotFound
		}
		return
	}
	return
}

func (a *Repo) bindToProfilePermission(id, profileID, isolatedEntityID string) error {
	res, err := a.db.NamedExec(sqlBindPermissionToProfile, argBindPermissionToProfile{
		ID:               id,
		CreatedBy:        profileID,
		IsolatedEntityID: isolatedEntityID,
	})
	if err != nil {
		return err
	}

	if count, _ := res.RowsAffected(); count == 0 {
		return app.ErrNotFound
	}
	return nil
}

func (a *Repo) editPermission(id string, isolatedEntityID string, m *app.Permission) error {

	res, err := a.db.NamedExec(sqlEditPermission, argEditPermission{
		ID:               id,
		Name:             m.Name,
		IsolatedEntityID: isolatedEntityID,
	})
	if err != nil {
		return err
	}

	if count, _ := res.RowsAffected(); count == 0 {
		return app.ErrNotFound
	}

	return nil
}

func (m *Permission) Filter(key string, filter *app.Filter) (ok bool, err error) {
	columnType := PermissionProps[key].typeName
	if err = validateOperator(filter.Operator, columnType); err != nil {
		return true, err
	}
	if err = vaidateIgnoreCase(filter.IgnoreCase, columnType); err != nil {
		return true, err
	}
	if err := validateValue(filter.Value, columnType); err != nil {
		return true, err
	}
	switch key {
	case "id":
		ok = compareUUID(filter.Operator, m.ID, filter.Value)
	case "name":
		ok = compareString(filter.Operator, filter.IgnoreCase, m.Name.String, filter.Value)
	default:
		ok, err = true, errNotExistFilterKey
	}
	return
}

func appPermission(m Permission) *app.Permission {
	if m.ID.String() == "00000000-0000-0000-0000-000000000000" {
		return nil
	}
	return &app.Permission{
		ID:   m.ID.String(),
		Name: m.Name.String,
	}
}

func appPermissions(ms []Permission) []*app.Permission {
	ams := []*app.Permission{}
	for _, m := range ms {
		ams = append(ams, appPermission(m))
	}

	return ams
}
