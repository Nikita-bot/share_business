// Code generated by mtgroup-generator.
package dal

import (
	"context"
	"database/sql"
	"encoding/json"
	"reflect"
	"strconv"
	"strings"
	"time"

	"wash-bonus/migration"

	"github.com/google/uuid"
	"github.com/jmoiron/sqlx"
	"github.com/pkg/errors"
	"github.com/powerman/pqx"
	"github.com/powerman/sqlxx"
	"github.com/powerman/structlog"
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

const (
	dbTimeout       = 3 * time.Second
	dbIdleTimeout   = 10 * time.Second
	dbMaxOpenConns  = 30 // about â…“ of server's max_connections
	dbParallelConns = 5  // a bit more than average
)

var log = structlog.New()

type Repo struct {
	db *DB
}

func connect(ctx context.Context, cfg pqx.Config, migrationDir string, resetDB bool) (*DB, error) {
	if resetDB {
		if err := migration.ResetAll(ctx, migrationDir, cfg); err != nil {
			return nil, err
		}
	}
	if err := migration.Up(ctx, migrationDir, cfg); err != nil {
		return nil, err
	}

	cfg.DefaultTransactionIsolation = sql.LevelSerializable
	cfg.StatementTimeout = dbTimeout
	cfg.LockTimeout = dbTimeout
	cfg.IdleInTransactionSessionTimeout = dbIdleTimeout

	db, err := sql.Open("postgres", cfg.FormatDSN())
	if err != nil {
		return nil, err
	}
	db.SetMaxOpenConns(dbMaxOpenConns)
	db.SetMaxIdleConns(dbParallelConns)

	err = db.PingContext(ctx)
	for err != nil {
		nextErr := db.PingContext(ctx)
		if nextErr == context.DeadlineExceeded {
			log.WarnIfFail(db.Close)
			return nil, errors.Wrap(err, "connect to postgres")
		}
		err = nextErr
	}

	return NewDB(sqlxx.NewDB(sqlx.NewDb(db, "postgres"))), nil
}

func New(ctx context.Context, dbCfg pqx.Config, migrationDir string, resetDB bool) (*Repo, error) {
	db, err := connect(ctx, dbCfg, migrationDir, resetDB)
	if err != nil {
		return nil, err
	}
	repo := &Repo{
		db: db,
	}
	return repo, nil
}

func (r *Repo) Close() {
	log.WarnIfFail(r.db.Close)
}

func filterCount(include bool, a, b interface{}) int {
	if include {
		if a == b {
			return 1
		}
	} else {
		if !(a == b) {
			return 1
		}
	}
	return 0
}

func toString(value interface{}) string {
	switch value.(type) {
	case string:
		return value.(string)
	case int:
		return strconv.FormatInt(int64(value.(int)), 10)
	case int32:
		return strconv.FormatInt(int64(value.(int32)), 10)
	case int64:
		return strconv.FormatInt(value.(int64), 10)
	case float64:
		return strconv.FormatFloat(value.(float64), 'f', -1, 64)
	case bool:
		if value.(bool) {
			return "true"
		}
		return "false"
	case time.Time:
		return value.(time.Time).String()
	case *time.Time:
		return value.(*time.Time).String()
	}
	return ""
}

func pagination(offset, limit, len int) (start, end int) {
	if limit == 0 {
		limit = len
	}
	if len > offset {
		start = offset
		if len >= offset+limit {
			end = offset + limit
		} else {
			end = len
		}
	} else {
		start, end = 0, 0
	}
	return
}

// contains is equal to strings.Contains but case insensitive
func contains(str, substr string) bool {
	return strings.Contains(strings.ToLower(str), strings.ToLower(substr))
}

func areEqualJSON(s1, s2 string) (bool, error) {
	var o1 interface{}
	var o2 interface{}

	var err error
	err = json.Unmarshal([]byte(s1), &o1)
	if err != nil {
		return false, err
	}
	err = json.Unmarshal([]byte(s2), &o2)
	if err != nil {
		return false, err
	}

	return reflect.DeepEqual(o1, o2), nil
}

func newNullUUID(s string) (nullUUID sql.NullString) {
	if _, err := uuid.Parse(s); err != nil {
		return
	}
	nullUUID.Scan(s)
	return
}

func newNullInt64ID(i int64) (nullInt64ID sql.NullInt64) {
	if i <= 0 {
		return
	}
	nullInt64ID.Scan(i)
	return
}
