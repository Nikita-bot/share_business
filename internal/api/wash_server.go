// Code generated by mtgroup-generator.
package api

import (
	"errors"
	"github.com/go-openapi/swag"
	"time"
	"wash-bonus/internal/def"

	"wash-bonus/internal/api/restapi/models"
	washServer "wash-bonus/internal/api/restapi/restapi/operations/wash_server"
	"wash-bonus/internal/app"

	"github.com/go-openapi/runtime/middleware"
	"github.com/go-openapi/strfmt"
	extauthapi "github.com/mtgroupit/mt-mock-extauthapi"
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!
func (svc *service) GetWashServer(params washServer.GetWashServerParams, profile interface{}) middleware.Responder {
	prof := profile.(*extauthapi.Profile)
	c, err := svc.app.GetWashServer(toAppProfile(prof), params.Body.ID)
	switch {
	default:
		log.PrintErr("GetWashServer server error", def.LogHTTPStatus, codeInternal.status, "code", codeInternal.extra, "err", err)
		return washServer.NewGetWashServerDefault(codeInternal.status).WithPayload(&models.Error{
			Code:    swag.Int32(codeInternal.extra),
			Message: swag.String("internal error"),
		})
	case errors.Is(err, app.ErrAccessDenied):
		log.Info("GetWashServer client error", def.LogHTTPStatus, codeForbidden.status, "code", codeForbidden.extra, "err", err)
		return washServer.NewGetWashServerDefault(codeForbidden.status).WithPayload(&models.Error{
			Code:    swag.Int32(codeForbidden.extra),
			Message: swag.String(err.Error()),
		})
	case errors.Is(err, app.ErrNotFound):
		log.Info("GetWashServer client error", def.LogHTTPStatus, codeNotFound.status, "code", codeNotFound.extra, "err", err)
		return washServer.NewGetWashServerDefault(codeNotFound.status).WithPayload(&models.Error{
			Code:    swag.Int32(codeNotFound.extra),
			Message: swag.String(err.Error()),
		})
	case err == nil:
		log.Info("GetWashServer ok", "id", params.Body.ID)
		return washServer.NewGetWashServerOK().WithPayload(apiWashServer(c))
	}
}
func (svc *service) AddWashServer(params washServer.AddWashServerParams, profile interface{}) middleware.Responder {
	prof := profile.(*extauthapi.Profile)
	c, err := svc.app.AddWashServer(toAppProfile(prof), appWashServerAdd(params.Body))
	switch {
	default:
		log.PrintErr("AddWashServer server error", def.LogHTTPStatus, codeInternal.status, "code", codeInternal.extra, "err", err)
		return washServer.NewAddWashServerDefault(codeInternal.status).WithPayload(&models.Error{
			Code:    swag.Int32(codeInternal.extra),
			Message: swag.String("internal error"),
		})
	case errors.Is(err, app.ErrAccessDenied):
		log.Info("AddWashServer client error", def.LogHTTPStatus, codeForbidden.status, "code", codeForbidden.extra, "err", err)
		return washServer.NewAddWashServerDefault(codeForbidden.status).WithPayload(&models.Error{
			Code:    swag.Int32(codeForbidden.extra),
			Message: swag.String(err.Error()),
		})
	case err == nil:
		log.Info("AddWashServer ok")
		return washServer.NewAddWashServerCreated().WithPayload(apiWashServer(c))
	}
}
func (svc *service) EditWashServer(params washServer.EditWashServerParams, profile interface{}) middleware.Responder {
	prof := profile.(*extauthapi.Profile)
	err := svc.app.EditWashServer(toAppProfile(prof), params.Body.ID, appWashServerAdd(params.Body.Data))
	switch {
	default:
		log.PrintErr("EditWashServer server error", def.LogHTTPStatus, codeInternal.status, "code", codeInternal.extra, "err", err)
		return washServer.NewEditWashServerDefault(codeInternal.status).WithPayload(&models.Error{
			Code:    swag.Int32(codeInternal.extra),
			Message: swag.String("internal error"),
		})
	case errors.Is(err, app.ErrAccessDenied):
		log.Info("EditWashServer client error", def.LogHTTPStatus, codeForbidden.status, "code", codeForbidden.extra, "err", err)
		return washServer.NewEditWashServerDefault(codeForbidden.status).WithPayload(&models.Error{
			Code:    swag.Int32(codeForbidden.extra),
			Message: swag.String(err.Error()),
		})
	case errors.Is(err, app.ErrNotFound):
		log.Info("EditWashServer client error", def.LogHTTPStatus, codeNotFound.status, "code", codeNotFound.extra, "err", err)
		return washServer.NewEditWashServerDefault(codeNotFound.status).WithPayload(&models.Error{
			Code:    swag.Int32(codeNotFound.extra),
			Message: swag.String(err.Error()),
		})
	case err == nil:
		log.Info("EditWashServer ok")
		return washServer.NewEditWashServerOK()
	}
}
func (svc *service) DeleteWashServer(params washServer.DeleteWashServerParams, profile interface{}) middleware.Responder {
	prof := profile.(*extauthapi.Profile)
	err := svc.app.DeleteWashServer(toAppProfile(prof), params.Body.ID)
	switch {
	default:
		log.PrintErr("DeleteWashServer server error", def.LogHTTPStatus, codeInternal.status, "code", codeInternal.extra, "err", err)
		return washServer.NewDeleteWashServerDefault(codeInternal.status).WithPayload(&models.Error{
			Code:    swag.Int32(codeInternal.extra),
			Message: swag.String("internal error"),
		})
	case errors.Is(err, app.ErrAccessDenied):
		log.Info("DeleteWashServer client error", def.LogHTTPStatus, codeForbidden.status, "code", codeForbidden.extra, "err", err)
		return washServer.NewDeleteWashServerDefault(codeForbidden.status).WithPayload(&models.Error{
			Code:    swag.Int32(codeForbidden.extra),
			Message: swag.String(err.Error()),
		})
	case errors.Is(err, app.ErrNotFound):
		log.Info("DeleteWashServer client error", def.LogHTTPStatus, codeNotFound.status, "code", codeNotFound.extra, "err", err)
		return washServer.NewDeleteWashServerDefault(codeNotFound.status).WithPayload(&models.Error{
			Code:    swag.Int32(codeNotFound.extra),
			Message: swag.String(err.Error()),
		})
	case err == nil:
		log.Info("DeleteWashServer ok", "id", params.Body.ID)
		return washServer.NewDeleteWashServerNoContent()
	}
}
func (svc *service) ListWashServer(params washServer.ListWashServerParams, profile interface{}) middleware.Responder {
	prof := profile.(*extauthapi.Profile)
	c, warnings, err := svc.app.ListWashServer(toAppProfile(prof), appListParams(params.Body))
	switch {
	default:
		log.PrintErr("ListWashServer server error", def.LogHTTPStatus, codeInternal.status, "code", codeInternal.extra, "err", err)
		return washServer.NewListWashServerDefault(codeInternal.status).WithPayload(&models.Error{
			Code:    swag.Int32(codeInternal.extra),
			Message: swag.String("internal error"),
		})
	case errors.Is(err, app.ErrAccessDenied):
		log.Info("ListWashServer client error", def.LogHTTPStatus, codeForbidden.status, "code", codeForbidden.extra, "err", err)
		return washServer.NewListWashServerDefault(codeForbidden.status).WithPayload(&models.Error{
			Code:    swag.Int32(codeForbidden.extra),
			Message: swag.String(err.Error()),
		})
	case err == nil:
		log.Info("ListWashServer ok")
		return washServer.NewListWashServerOK().WithPayload(&washServer.ListWashServerOKBody{
			Items:    apiWashServers(c),
			Warnings: warnings,
		})
	}
}

func apiWashServer(a *app.WashServer) *models.WashServer {
	if a == nil {
		return nil
	}
	return &models.WashServer{
		ID:           a.ID,
		CreatedAt:    (*strfmt.DateTime)(a.CreatedAt),
		Key:          a.Key,
		LastUpdateAt: (*strfmt.DateTime)(a.LastUpdateAt),
		ModifiedAt:   (*strfmt.DateTime)(a.ModifiedAt),
		Name:         a.Name,
	}
}

func apiWashServers(apps []*app.WashServer) []*models.WashServer {
	apis := []*models.WashServer{}
	for i := range apps {
		apis = append(apis, apiWashServer(apps[i]))
	}
	return apis
}

func appWashServer(a *models.WashServer) *app.WashServer {
	if a == nil {
		return nil
	}
	washServer := &app.WashServer{}
	washServer.ID = a.ID
	washServer.CreatedAt = (*time.Time)(a.CreatedAt)
	washServer.Key = a.Key
	washServer.LastUpdateAt = (*time.Time)(a.LastUpdateAt)
	washServer.ModifiedAt = (*time.Time)(a.ModifiedAt)
	washServer.Name = a.Name

	return washServer
}

func appWashServers(apis []*models.WashServer) []*app.WashServer {
	apps := []*app.WashServer{}
	for i := range apis {
		apps = append(apps, appWashServer(apis[i]))
	}
	return apps
}

func appWashServerAdd(a *models.WashServerAdd) *app.WashServer {
	if a == nil {
		return nil
	}
	washServer := &app.WashServer{}
	washServer.Key = a.Key
	washServer.LastUpdateAt = (*time.Time)(a.LastUpdateAt)
	washServer.Name = a.Name

	return washServer
}

func appWashServersAdd(apis []*models.WashServerAdd) []*app.WashServer {
	apps := []*app.WashServer{}
	for i := range apis {
		apps = append(apps, appWashServerAdd(apis[i]))
	}
	return apps
}
